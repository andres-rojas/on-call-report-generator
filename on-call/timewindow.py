from helper import debug, ISO_8601_COMBINED_FORMAT, ISO_8601_DATE_FORMAT
from settings import END_OFF, END_PEAK, START_OFF, START_PEAK, TIME_ZONE, UNTIL

import datetime
import dateutil.parser
import pytz


def tz_aware(dt, tz):
    """
    Ensures that a datetime object is time zone aware.
    Only makes changes to naive datetime objects.

    :param dt: datetime -- any valid datetime object
    :param tz: string in IANA time zone database format -- the timezone to attach to the object
    :returns: datetime -- a time zone aware version of the given dt object
    """

    if dt.tzinfo is None or dt.tzinfo.utcoffset(dt) is None:
        return pytz.timezone(tz).localize(dt)
    else:
        return dt


def end_datetime(incident, until=UNTIL, time_zone=TIME_ZONE):
    """
    Gets the incident end datetime within the reporting window.

    :param incident: dictionary -- an incident object generated by pygerduty.incidents()
    :param until: string in ISO 8601 combined datetime format -- the end of the reporting window
    :param time_zone: string in IANA time zone database format -- the time zone in use
    :returns: datetime -- the end of the incident within the reporting period window
    """

    if incident.status == 'resolved':
        end = incident.last_status_change_at
    else:
        end = until

    return tz_aware(dateutil.parser.parse(end), time_zone)


def duration(incident, until=UNTIL):
    """
    Gets the duration of an incident within the reporting window.

    :param incident: dictionary -- an incident object generated by pygerduty.incidents()
    :param until: string in ISO 8601 combined datetime format -- the end of the reporting window
    :returns: datetime.timedelta -- duration of the incident within the reporting window
    """

    start = dateutil.parser.parse(incident.created_at)
    end = end_datetime(incident, until)

    return end - start


def add_date_to_time(date, time, time_zone=TIME_ZONE):
    """
    Prepends a given date to a given time.

    :param date: string in ISO 8601 date format
    :param time: string in ISO 8601 extended time format
    :returns: datetime -- combined datetime object
    """

    return tz_aware(dateutil.parser.parse(date + 'T' + time), time_zone)


def during(event_start, event_end, window_start, window_end, until=UNTIL, time_zone=TIME_ZONE):
    """
    Determines if an event occurs within a time window within the reporting period.

    :param event_start: datetime -- incident start
    :param event_end: datetime -- incident end
    :param window_start: string in ISO 8601 extended time format -- off-hours start time
    :param window_end: string in ISO 8601 extended time format -- off-hours end time
    :param until: string in ISO 8601 combined datetime format -- the end of the reporting window
    :returns: boolean -- true if, and only if, event is within the window
    """

    debug('Checking if ' + event_start.strftime(ISO_8601_COMBINED_FORMAT)
          + ' to ' + event_end.strftime(ISO_8601_COMBINED_FORMAT)
          + ' falls between ' + window_start + '-' + window_end, 3)

    if event_end - event_start >= datetime.timedelta(days=1):
        return True
    else:
        if event_start.toordinal() == event_end.toordinal():
            if window_start < window_end:
                check_day = event_start.strftime(ISO_8601_DATE_FORMAT)

                window_start_dt = add_date_to_time(check_day, window_start)
                window_end_dt = add_date_to_time(check_day, window_end)

                return (window_start_dt < event_start < window_end_dt
                        or window_start_dt < event_end < window_end_dt)
            else:
                return (during(event_start, event_end, '00:00:00', window_end)
                        or during(event_start, event_end, window_start, '23:59:59'))
        else:
            if window_start < window_end:
                end_of_day = event_start.replace(hour=23, minute=59, second=59)
                beginning_of_day = event_end.replace(hour=0, minute=0, second=0)

                return (during(event_start, end_of_day, window_start, window_end)
                        or during(beginning_of_day, event_end, window_start, window_end))
            else:
                start_day = event_start.strftime(ISO_8601_DATE_FORMAT)
                end_day = event_end.strftime(ISO_8601_DATE_FORMAT)

                window_start_dt = add_date_to_time(start_day, window_start)
                window_end_dt = add_date_to_time(end_day, window_end)

                return (window_start_dt < event_start < window_end_dt
                        or window_start_dt < event_end < window_end_dt)


def during_off_hours(incident):
    if incident.urgency != 'low':
        debug('Checking if during off hours...', 2)
        if during(dateutil.parser.parse(incident.created_at),
                  end_datetime(incident, UNTIL),
                  START_OFF, END_OFF):
            debug('Occurred during off hours!', 3)
            return True
        else:
            return False


def during_peak_sleep(incident):
    if incident.urgency != 'low':
        debug('Checking if during peak sleep...', 2)
        if during(dateutil.parser.parse(incident.created_at),
                  end_datetime(incident, UNTIL),
                  START_PEAK, END_PEAK):
            debug('Occurred during peak sleep!', 3)
            return True
    else:
        return False
