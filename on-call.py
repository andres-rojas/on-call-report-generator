#!/usr/bin/env python3

"""
This will generate an on-call report based on information pulled from
PagerDuty's API. The report will be generated in ConfluenceWiki format
and will be posted to a target space/path in a target Confluence wiki.

Usage: ./on-call.py SINCE_DAY UNTIL_DAY

SINCE_DAY -- ISO 8601 date
UNTIL_DAY -- ISO 8601 date

i.e. ./on-call.py 2017-07-24 2017-07-31
"""

import datetime
import dateutil.parser
import os
import pygerduty.v2
import pytz
import sys


DEBUG       = True
VERBOSITY   = 3
INDENT_SIZE = 4

PAGERDUTY_TOKEN = os.environ['PAGERDUTY_TOKEN']

ISO_8601_DATE_FORMAT     = '%Y-%m-%d'
ISO_8601_TIME_FORMAT     = '%H:%M:%S'
ISO_8601_COMBINED_FORMAT = ISO_8601_DATE_FORMAT + 'T' + ISO_8601_TIME_FORMAT + '%z'

TIME_ZONE = 'PST8PDT'               #: IANA time zone database format

SINCE = sys.argv[1] + 'T09:30:00'   #: ISO 8601 combined datetime format
UNTIL = sys.argv[2] + 'T09:29:59'   #: ISO 8601 combined datetime format

START_OFF  = '17:30:00'             #: ISO 8601 extended time format
END_OFF    = '08:30:00'             #: ISO 8601 extended time format
START_PEAK = '00:00:00'             #: ISO 8601 extended time format
END_PEAK   = '06:00:00'             #: ISO 8601 extended time format


def debug(message='', verbosity=1):
  """
  Prints debug messages to stderr at varying verbosity levels

  :param message: string -- debug message
  :param verbosity: int -- verbosity level
  """

  if DEBUG and VERBOSITY >= verbosity:
    sys.stderr.write((' ' * INDENT_SIZE * (verbosity - 1)) + message + '\n')


def tz_aware(dt, tz):
  """
  Ensures that a datetime object is time zone aware.
  Only makes changes to naive datetime objects.

  :param dt: datetime -- any valid datetime object
  :param tz: string in IANA time zone database format -- the timezone to attach to the object
  :returns: datetime -- a time zone aware version of the given dt object
  """

  if dt.tzinfo is None or dt.tzinfo.utcoffset(dt) is None:
    return pytz.timezone(tz).localize(dt)
  else:
    return dt


def end_datetime(incident, until=UNTIL, time_zone=TIME_ZONE):
  """
  Gets the incident end datetime within the reporting window.

  :param incident: dictionary -- an incident object generated by pygerduty.incidents()
  :param until: string in ISO 8601 combined datetime format -- the end of the reporting window
  :param time_zone: string in IANA time zone database format -- the time zone in use
  :returns: datetime -- the end of the incident within the reporting period window
  """

  if incident.status == 'resolved':
    end = incident.last_status_change_at
  else:
    end = until

  return tz_aware(dateutil.parser.parse(end), time_zone)


def duration(incident, until=UNTIL):
  """
  Gets the duration of an incident within the reporting window.

  :param incident: dictionary -- an incident object generated by pygerduty.incidents()
  :param until: string in ISO 8601 combined datetime format -- the end of the reporting window
  :returns: datetime.timedelta -- duration of the incident within the reporting window
  """

  start = dateutil.parser.parse(incident.created_at)
  end = end_datetime(incident, until)

  return end - start


def add_date_to_time(date, time, time_zone=TIME_ZONE):
  """
  Prepends a given date to a given time.

  :param date: string in ISO 8601 date format
  :param time: string in ISO 8601 extended time format
  :returns: datetime -- combined datetime object
  """

  return tz_aware(dateutil.parser.parse(date + 'T' + time), time_zone)


def during(event_start, event_end, window_start, window_end, until=UNTIL, time_zone=TIME_ZONE):
  """
  Determines if an event occurs within a time window within the reporting period.

  :param event_start: datetime -- incident start
  :param event_end: datetime -- incident end
  :param window_start: string in ISO 8601 extended time format -- off-hours start time
  :param window_end: string in ISO 8601 extended time format -- off-hours end time
  :param until: string in ISO 8601 combined datetime format -- the end of the reporting window
  :returns: boolean -- true if, and only if, event is within the window
  """

  debug('Checking if ' + event_start.strftime(ISO_8601_COMBINED_FORMAT) + ' to ' + event_end.strftime(ISO_8601_COMBINED_FORMAT) + ' falls between ' + window_start + '-' + window_end, 3)

  if event_end - event_start >= datetime.timedelta(days=1):
    return True
  else:
    if event_start.toordinal() == event_end.toordinal():
      if window_start < window_end:
        check_day = event_start.strftime(ISO_8601_DATE_FORMAT)

        window_start_dt = add_date_to_time(check_day, window_start)
        window_end_dt = add_date_to_time(check_day, window_end)

        return window_start_dt < event_start < window_end_dt or window_start_dt < event_end < window_end_dt
      else:
        return during(event_start, event_end, '00:00:00', window_end) or during(event_start, event_end, window_start, '23:59:59')
    else:
      if window_start < window_end:
        end_of_day = event_start.replace(hour=23, minute=59, second=59)
        beginning_of_day = event_end.replace(hour=0, minute=0, second=0)

        return during(event_start, end_of_day, window_start, window_end) or during(beginning_of_day, event_end, window_start, window_end)
      else:
        start_day = event_start.strftime(ISO_8601_DATE_FORMAT)
        end_day = event_end.strftime(ISO_8601_DATE_FORMAT)

        window_start_dt = add_date_to_time(start_day, window_start)
        window_end_dt = add_date_to_time(end_day, window_end)

        return window_start_dt < event_start < window_end_dt or window_start_dt < event_end < window_end_dt


def total_incidents(incidents, type):
  """
  Gets total number of incidents of a certain type

  :param incidents: dictionary - set of incidents to parse
  :param type: string - key to parse within incidents
  :return: int - total incidents
  """

  total = 0

  for _, incident in incidents.items():
    total += incident[type]

  return total


if __name__ == '__main__':
  pager = pygerduty.v2.PagerDuty(PAGERDUTY_TOKEN)
  debug('Connecting to PagerDuty...\n')

  incidents = {}
  for incident in pager.incidents.list(since=SINCE, until=UNTIL, time_zone=TIME_ZONE):
    debug('New "' + incident.title + '" incident!')

    if incident.title not in incidents:
      incidents[incident.title] = {
        'urgency': incident.urgency,
        'total_duration': datetime.timedelta(),
        'total_incidents': 0,
        'off_hours': 0,
        'peak_sleep': 0
      }

    incidents[incident.title]['total_duration'] += duration(incident)
    debug('Total duration to ' + str(incidents[incident.title]['total_duration']), 2)

    incidents[incident.title]['total_incidents'] += 1
    debug('Total incidents to ' + str(incidents[incident.title]['total_incidents']), 2)

    if incident.urgency != 'low':
      debug('Checking if during off hours...', 2)
      if during(dateutil.parser.parse(incident.created_at), end_datetime(incident, UNTIL), START_OFF, END_OFF):
        incidents[incident.title]['off_hours'] += 1
        debug('Occurred during off hours!', 3)

      debug('Checking if during peak sleep...', 2)
      if during(dateutil.parser.parse(incident.created_at), end_datetime(incident, UNTIL), START_PEAK, END_PEAK):
        incidents[incident.title]['peak_sleep'] += 1
        debug('Occurred during peak sleep!', 3)

    debug()

  debug()

  for incident, metrics in incidents.items():
    print(incident + ':')
    print('            Urgency:', metrics['urgency'])
    print('     Total Duration:', metrics['total_duration'])
    print('    Total Incidents:', metrics['total_incidents'])
    print('   Off Hours Alerts:', metrics['off_hours'])
    print('  Peak Sleep Alerts:', metrics['peak_sleep'], '\n')

  print('\n Total Off Hours Alerts:', total_incidents(incidents, 'off_hours'))
  print('Total Peak Sleep Alerts:', total_incidents(incidents, 'peak_sleep'))

